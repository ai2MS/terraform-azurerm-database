#cloud-config
package_update: true
package_upgrade: true

packages:
  - snapd
  - python3
  - python3-pip
  - python3-venv

write_files:
  - path: /root/install-packages.yml
    owner: root:root
    permissions: "0644"
    content: |
      ---
      - name: Install required packages
        hosts: localhost
        remote_user: ${admin_username}
        gather_facts: yes
        become: true

        tasks:
          - name: Install base packages
            apt:
              name:
                - curl
                - unzip
                - gnupg
                - git
                - apt-transport-https
                - ca-certificates
                - lsb-release
              state: present

          - name: Update apt cache
            apt:
              update_cache: yes

          - name: Install microk8s
            snap:
              name: microk8s
              classic: true
              channel: ${microk8s_channel}

          - name: Install helm
            snap:
              name: helm
              classic: true

          - name: Install docker
            snap:
              name: docker

          - name: Install ollama
            shell: curl -fsSL https://ollama.com/install.sh | sh
            args:
              creates: /usr/local/bin/ollama

          - name: Add current user to microk8s group
            user:
              name: "{{ ansible_user_id }}"
              groups: microk8s
              append: true

          - name: Enable microk8s addons
            shell: |
              microk8s status --wait-ready
              microk8s enable dns storage ingress
            args:
              creates: /var/snap/microk8s/current/args/kubelet

          - name: Create kube config directory
            file:
              path: "/home/{{ ansible_user_id }}/.kube"
              state: directory
              owner: "{{ ansible_user_id }}"
              mode: "0755"

          - name: Export microk8s kubeconfig
            shell: |
              microk8s config > /home/{{ ansible_user_id }}/.kube/config
            args:
              creates: "/home/{{ ansible_user_id }}/.kube/config"

          - name: Fix kubeconfig permissions
            file:
              path: "/home/{{ ansible_user_id }}/.kube/config"
              owner: "{{ ansible_user_id }}"
              mode: "0600"

          - name: Create kubectl alias from microk8s
            command: snap alias microk8s.kubectl kubectl
            args:
              creates: /snap/bin/kubectl

          - name: Install kubelogin
            shell: az aks install-cli
            args:
              creates: /usr/local/bin/kubelogin

  - path: /root/.env
    owner: root:root
    permissions: "0600"
    content: |
      # GHCR CREDENTIALS
      GITHUB_USERNAME=${env_github_username}
      GITHUB_EMAIL=${env_github_email}

      # INFRASTRUCTURE SECRETS
      POSTGRES_PASSWORD=${env_postgres_password}
      REDIS_PASSWORD=${env_redis_password}
      QDRANT_API_KEY=${env_qdrant_api_key}
      
      # AIOPS-DYNATRACE-KAFKA SECRETS
      DYNATRACE_API_TOKEN=${env_dynatrace_api_token}

      # AIOPS-MCPSVR-SNOW SECRETS
      SERVICENOW_INSTANCE_URL=${env_servicenow_instance_url}
      SERVICENOW_USERNAME=${env_servicenow_username}
      SERVICENOW_PASSWORD=${env_servicenow_password}
      SERVICENOW_API_KEY=${env_servicenow_api_key}
      SERVICENOW_CLIENT_ID=${env_servicenow_client_id}
      SERVICENOW_CLIENT_SECRET=${env_servicenow_client_secret}

      # AIOPS-INTELLIPORT SECRETS
      OPENAI_API_KEY=${env_openai_api_key}
      AZURE_OPENAI_API_KEY=${env_azure_openai_api_key}
      JIRA_API_KEY=${env_jira_api_key}
      GITHUB_API_KEY=${env_github_api_key}
      ENCRYPTION_KEY=${env_encryption_key}

  - path: /root/deploy-app.yml
    owner: root:root
    permissions: "0644"
    content: |
      ---
      - name: Deploy application from Git repository
        hosts: localhost
        remote_user: ${admin_username}
        gather_facts: yes
        become: true

        vars:
          git_repo_url: "${git_repo_url}"
          git_repo_branch: "${git_repo_branch}"
          git_pat: "${git_personal_access_token}"
          clone_path: "${git_repo_clone_path}"
          script_path: "${deployment_script_path}"
          env_file_source: "/root/.env"

        tasks:
          - name: Ensure parent directory exists
            file:
              path: "{{ clone_path | dirname }}"
              state: directory
              mode: "0755"

          - name: Construct authenticated Git URL (if PAT provided)
            set_fact:
              authenticated_repo_url: "{{ git_repo_url | regex_replace('^https://', 'https://' + git_pat + '@') }}"
            when: git_pat != ""
            no_log: true

          - name: Use original URL (if no PAT)
            set_fact:
              authenticated_repo_url: "{{ git_repo_url }}"
            when: git_pat == ""

          - name: Clone Git repository
            git:
              repo: "{{ authenticated_repo_url }}"
              dest: "{{ clone_path }}"
              version: "{{ git_repo_branch }}"
              force: yes
              accept_hostkey: yes
              update: yes
              depth: 1
            register: git_clone_result
            environment:
              GIT_TERMINAL_PROMPT: "0"
            no_log: true

          - name: Display clone result
            debug:
              msg: "Repository cloned to {{ clone_path }} ({{ git_clone_result.after | default('no commit info') }})"

          - name: Copy .env file to cloned repository
            copy:
              src: "{{ env_file_source }}"
              dest: "{{ clone_path }}/.env"
              owner: ${admin_username}
              group: ${admin_username}
              mode: "0600"
              remote_src: yes

          - name: Make deployment script executable
            file:
              path: "{{ clone_path }}/{{ script_path }}"
              mode: "0755"
            when: script_path != ""

#          - name: Run deployment script
#            shell: |
#              cd {{ clone_path }}
#              ./{{ script_path }}
#            args:
#              executable: /bin/bash
#            when: script_path != ""
#            register: script_result
#
#          - name: Display script output
#            debug:
#              msg: "{{ script_result.stdout_lines | default(['Script execution skipped']) }}"
#            when: script_path != ""
#
#          - name: Display script errors (if any)
#            debug:
#              msg: "{{ script_result.stderr_lines }}"
#            when: script_path != "" and script_result.stderr_lines is defined and script_result.stderr_lines | length > 0

  - path: /root/show-versions.yml
    owner: root:root
    permissions: "0644"
    content: |
      ---
      - name: Show package versions
        hosts: localhost
        remote_user: ${admin_username}
        gather_facts: no
        become: false

        tasks:
          - name: Helm version
            shell: "helm version --short || helm version"
            register: helm_version
            ignore_errors: true
          - debug:
              msg: "{{ helm_version.stdout | default('Helm: not installed') }}"

          - name: kubelogin version
            shell: "kubelogin --version"
            register: kubelogin_version
            ignore_errors: true
          - debug:
              msg: "{{ kubelogin_version.stdout | default('kubelogin: not installed') }}"

          - name: Azure CLI version
            shell: "az version | grep azure-cli | awk -F'\"' '{print $4}'"
            register: az_version
            ignore_errors: true
          - debug:
              msg: "{{ az_version.stdout | default('Azure CLI: not installed') }}"

          - name: Git version
            shell: "git --version"
            register: git_version
            ignore_errors: true
          - debug:
              msg: "{{ git_version.stdout | default('Git: not installed') }}"

          - name: MicroK8s version
            shell: "microk8s version --short || microk8s version"
            register: microk8s_version
            ignore_errors: true
          - debug:
              msg: "{{ microk8s_version.stdout | default('MicroK8s: not installed') }}"

          - name: Ollama version
            shell: "ollama -v"
            register: ollama_version
            ignore_errors: true
          - debug:
              msg: "{{ ollama_version.stdout | default('Ollama: not installed') }}"

          - name: Docker version
            shell: "docker --version"
            register: docker_version
            ignore_errors: true
          - debug:
              msg: "{{ docker_version.stdout | default('Docker: not installed') }}"

          - name: kubectl version
            shell: "kubectl version --client --short || kubectl version --client"
            register: kubectl_version
            ignore_errors: true
          - debug:
              msg: "{{ kubectl_version.stdout | default('kubectl: not installed') }}"

          - name: Python version
            shell: "python3 --version"
            register: python_version
            ignore_errors: true
          - debug:
              msg: "{{ python_version.stdout | default('Python: not installed') }}"

runcmd:
  - [ echo, "Starting cloud-init runcmd execution..." ]
  - [ systemctl, enable, --now, snapd.socket ]
  - [ echo, "Upgrading pip..." ]
  - [ /usr/bin/python3, -m, pip, install, --upgrade, pip ]
  - [ /usr/bin/python3, -m, pip, config, set, global.disable-pip-version-check, "true" ]
  - [ echo, "Installing ansible and azure cli..." ]
  - [ python3, -m, pip, install, ansible==${ansible_version}, azure-cli==${azure_cli_version} ]
  - [ echo, "Running ansible playbook: install-packages.yml..." ]
  - [ ansible-playbook, /root/install-packages.yml, -v ]
  - [ echo, "Running ansible playbook: show-versions.yml..." ]
  - [ ansible-playbook, /root/show-versions.yml, -v ]
  - [ echo, "Running ansible playbook: deploy-app.yml..." ]
  - [ ansible-playbook, /root/deploy-app.yml, -v ]
  - [ echo, "Cloud-init runcmd execution finished successfully." ]

